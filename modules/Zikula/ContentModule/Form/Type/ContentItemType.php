<?php

/**
 * Content.
 *
 * @copyright Axel Guckelsberger (Zikula)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @author Axel Guckelsberger <info@ziku.la>.
 * @see https://ziku.la
 * @version Generated by ModuleStudio 1.4.0 (https://modulestudio.de).
 */

declare(strict_types=1);

namespace Zikula\ContentModule\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Zikula\Common\Content\ContentTypeInterface;
use Zikula\Common\Translator\TranslatorInterface;
use Zikula\Common\Translator\TranslatorTrait;
use Zikula\ContentModule\Entity\ContentItemEntity;
use Zikula\ContentModule\Form\Type\Field\MultiListType;
use Zikula\ContentModule\Helper\ListEntriesHelper;
use Zikula\ExtensionsModule\Api\ApiInterface\VariableApiInterface;

/**
 * Content item editing form type implementation class.
 */
class ContentItemType extends AbstractType
{
    use TranslatorTrait;

    /**
     * @var ListEntriesHelper
     */
    private $listHelper;

    /**
     * @var string
     */
    private $stylingClasses;

    public function __construct(
        TranslatorInterface $translator,
        ListEntriesHelper $listHelper,
        VariableApiInterface $variableApi
    ) {
        $this->setTranslator($translator);
        $this->listHelper = $listHelper;
        $this->stylingClasses = $variableApi->get('ZikulaContentModule', 'contentStyles', '');
    }

    public function setTranslator(TranslatorInterface $translator): void
    {
        $this->translator = $translator;
    }

    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        if (null !== $options['content_type']) {
            $editFormClass = $options['content_type']->getEditFormClass();
            if (null !== $editFormClass && '' !== $editFormClass && class_exists($editFormClass)) {
                $builder->add('contentData', $editFormClass,
                    $options['content_type']->getEditFormOptions(ContentTypeInterface::CONTEXT_EDIT)
                );
            }
        }
        $builder->add('active', CheckboxType::class, [
            'label' => $this->__('Active') . ':',
            'attr' => [
                'title' => $this->__('active ?')
            ],
            'required' => false,
        ]);

        $builder->add('activeFrom', DateTimeType::class, [
            'label' => $this->__('Active from') . ':',
            'attr' => [
                'class' => 'validate-daterange-page'
            ],
            'required' => false,
            'empty_data' => '',
            'with_seconds' => true,
            'date_widget' => 'single_text',
            'time_widget' => 'single_text'
        ]);

        $builder->add('activeTo', DateTimeType::class, [
            'label' => $this->__('Active to') . ':',
            'attr' => [
                'class' => 'validate-daterange-page'
            ],
            'required' => false,
            'empty_data' => '',
            'with_seconds' => true,
            'date_widget' => 'single_text',
            'time_widget' => 'single_text'
        ]);

        $listEntries = $this->listHelper->getEntries('contentItem', 'scope');
        $choices = [];
        $choiceAttributes = [];
        foreach ($listEntries as $entry) {
            $choices[$entry['text']] = $entry['value'];
            $choiceAttributes[$entry['text']] = ['title' => $entry['title']];
        }
        $helpText = $this->__('As soon as at least one selected entry applies for the current user the content becomes visible.');
        $builder->add('scope', MultiListType::class, [
            'label' => $this->__('Scope') . ':',
            'label_attr' => [
                'class' => 'tooltips checkbox-inline',
                'title' => $helpText
            ],
            'help' => $helpText,
            'empty_data' => '0',
            'attr' => [
                'class' => '',
                'title' => $this->__('Choose the scope.')
            ],
            'required' => true,
            'choices' => $choices,
            'choice_attr' => $choiceAttributes,
            'multiple' => true,
            'expanded' => true
        ]);

        $choices = [];
        $userClasses = explode("\n", $this->stylingClasses);
        foreach ($userClasses as $class) {
            list($value, $text) = explode('|', $class);
            $value = trim($value);
            $text = trim($text);
            if (!empty($text) && !empty($value)) {
                $choices[$text] = $value;
            }
        }

        $builder->add('stylingClasses', ChoiceType::class, [
            'label' => $this->__('Styling classes') . ':',
            'empty_data' => [],
            'attr' => [
                'title' => $this->__('Choose any additional styling classes.')
            ],
            'required' => false,
            'choices' => $choices,
            'multiple' => true
        ]);

        $helpText = $this->__('You may enter any text which will be used during the site search to find this element.');
        $builder->add('additionalSearchText', TextType::class, [
            'label' => $this->__('Additional search text') . ':',
            'empty_data' => '',
            'attr' => [
                'maxlength' => 255,
                'title' => $helpText
            ],
            'required' => false,
            'help' => $helpText
        ]);
    }

    public function getBlockPrefix()
    {
        return 'zikulacontentmodule_contentitem';
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => ContentItemEntity::class,
            'content_type' => null
        ]);
    }
}
